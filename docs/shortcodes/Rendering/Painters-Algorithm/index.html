<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Painters' Algorithm #  El algoritmo del pintor, también algoritmo de ordenación de la profundidad o relleno prioritario, es un algoritmo para la determinación de la superficie visible en gráficos 3D,que funciona polígono a polígono para la eliminación de superficies ocultas al punto de vista del observador. Este algoritmo crea imágenes clasificando los polígonos dentro de la imagen por su profundidad y colocando cada polígono en orden desde el objeto más lejano al más cercano.">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content>
<meta property="og:description" content="Painters' Algorithm #  El algoritmo del pintor, también algoritmo de ordenación de la profundidad o relleno prioritario, es un algoritmo para la determinación de la superficie visible en gráficos 3D,que funciona polígono a polígono para la eliminación de superficies ocultas al punto de vista del observador. Este algoritmo crea imágenes clasificando los polígonos dentro de la imagen por su profundidad y colocando cada polígono en orden desde el objeto más lejano al más cercano.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Rendering/Painters-Algorithm/"><meta property="article:section" content="docs">
<meta property="article:modified_time" content="2021-12-13T01:01:53-05:00">
<title>Painters Algorithm | Visual Computing</title>
<link rel=manifest href=/vc/manifest.json>
<link rel=icon href=/vc/favicon.png type=image/x-icon>
<link rel=stylesheet href=/vc/book.min.89a77f7e702a8626749b948bbfb01109823daf6c1246ca407d1378833494c402.css integrity="sha256-iad/fnAqhiZ0m5SLv7ARCYI9r2wSRspAfRN4gzSUxAI=" crossorigin=anonymous>
<script defer src=/vc/flexsearch.min.js></script>
<script defer src=/vc/en.search.min.a92c55a672b12a5cd85b62aeaa46732ba35709e4ba03eecce992a0005561a165.js integrity="sha256-qSxVpnKxKlzYW2KuqkZzK6NXCeS6A+7M6ZKgAFVhoWU=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/vc/><span>Visual Computing</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li class=book-section-flat>
<span>Shortcodes</span>
<ul>
<li>
<input type=checkbox id=section-7c3caa3f9736d0448c142e930fa4817c class=toggle>
<label for=section-7c3caa3f9736d0448c142e930fa4817c class="flex justify-between">
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/>Integrantes</a>
</label>
<ul>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Alejandra-Zambrano/>Alejandra Zambrano</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Andres-Ardila/>Andres Ardila</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Catalina-Aldana/>Catalina Aldana</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Diego-Bayona/>Diego Bayona</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Lucas-Pe%C3%B1a/>Lucas Peña</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Integrantes/Test/>Test</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-316bf254ad8f46bde0f17dc0171e06ba class=toggle checked>
<label for=section-316bf254ad8f46bde0f17dc0171e06ba class="flex justify-between">
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Rendering/>Rendering</a>
</label>
<ul>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Rendering/Painters-Algorithm/ class=active>Painters Algorithm</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Rendering/Rasterizaci%C3%B3n/>Rasterización</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Rendering/Vertex-Shander-and-Fragment-Shader/>Vertex Shander and Fragment Shader</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-02b3f844310127585a6f36afa15fba0f class=toggle>
<label for=section-02b3f844310127585a6f36afa15fba0f class="flex justify-between">
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Taller-Final/>Taller Final</a>
</label>
<ul>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Taller-Final/Mosaico/>Mosaico</a>
</li>
<li>
<a href=https://visualcomputing-vc20212.github.io/vc/docs/shortcodes/Taller-Final/WebCrawler/>Web Crawler</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/vc/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Painters Algorithm</strong>
<label for=toc-control>
<img src=/vc/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#painters-algorithm>Painters' Algorithm</a>
<ul>
<li>
<ul>
<li><a href=#pseudocódigo>Pseudocódigo</a></li>
<li><a href=#complejidad-temporal>Complejidad temporal</a></li>
<li><a href=#complejidad-espacial>Complejidad espacial</a></li>
<li><a href=#referencias>Referencias</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=painters-algorithm>
Painters' Algorithm
<a class=anchor href=#painters-algorithm>#</a>
</h1>
<p>El algoritmo del pintor, también algoritmo de ordenación de la profundidad o relleno prioritario, es un algoritmo para la determinación de la superficie visible en gráficos 3D,que funciona polígono a polígono para la eliminación de superficies ocultas al punto de vista del observador. Este algoritmo crea imágenes clasificando los polígonos dentro de la imagen por su profundidad y colocando cada polígono en orden desde el objeto más lejano al más cercano.</p>
<p>Fue propuesto inicialmente como un método básico para abordar el <em>problema de la determinación de la superficie oculta</em> por Martin Newell, Richard Newell y Tom Sancha en 1972. Se llama así porque el pintado del cuadro se hace en orden decreciente de la distancia. La distancia es desde el plano de la vista. Los polígonos a más distancia se pintan primero.</p>
<p>Cuando el pintor hace un cuadro, primero pinta todo el lienzo con el color de fondo. Luego, se añaden los objetos más lejanos, como las montañas o los árboles. A continuación, se añaden al cuadro los objetos posteriores o de primer plano.</p>
<center><img src=https://media.giphy.com/media/JnFjMQgSDNPV7EFcbF/giphy.gif></center>
<p>Los objetos están dispuestos en orden creciente a la coordenada z. El renderizado se realiza en orden de la coordenada z. Los objetos más lejanos oscurecerán a los cercanos. Los píxeles de la parte trasera sobrescribirán los píxeles de los objetos más lejanos.</p>
<p>Si los valores z de dos se superponen, podemos determinar el orden correcto a partir del valor Z como se muestra en la figura (a).</p>
<p>Si los objetos z se superponen entre sí, como en la figura (b), este correcto orden se puede mantener cortando los objetos superpuestos.</p>
<center><img src=https://edunextuploads.s3.amazonaws.com/1639374264845618174708.jpg></center>
<h3 id=pseudocódigo>
Pseudocódigo
<a class=anchor href=#pseudoc%c3%b3digo>#</a>
</h3>
<p>Pasos realizados en la clasificación en profundidad</p>
<ol>
<li>Ordenar todos los polígonos según la coordenada z.</li>
<li>Encontrar ambigüedades: encontrar si la coordenada z se superpone, dividir el polígono si es necesario.</li>
<li>Convertir cada polígono en orden creciente de la coordenada z.</li>
</ol>
<pre tabindex=0><code>sort polygons by depth 
    for each polygon p:
        for each pixel that p covers:
            paint p.color on pixel
</code></pre><p>Se aplica la prueba:</p>
<ol>
<li>¿A está detrás de B y no se solapa con él en la dimensión de Z como se muestra en la figura (a)?</li>
<li>Si A está detrás de B en z y no se solapa en x o y como se muestra en la fig (b)</li>
<li>Si A está detrás de B en Z y totalmente fuera de B con respecto al plano de la vista como se muestra en la fig (c)</li>
<li>Si A está detrás de B en Z y B está totalmente dentro de A con respecto al plano de visión, como se muestra en la figura (d)</li>
</ol>
<center><img src=https://edunextuploads.s3.amazonaws.com/163937429751712709052.jpg></center>
<h3 id=complejidad-temporal>
Complejidad temporal
<a class=anchor href=#complejidad-temporal>#</a>
</h3>
<p>La complejidad temporal depende en gran medida del algoritmo de ordenamiento utilizado para ordenar los polígonos. Suponiendo el uso del algoritmo de ordenamiento más óptimo, el algoritmo de pintor tiene una complejidad en el peor de los casos:
<link rel=stylesheet href=/vc/katex/katex.min.css>
<script defer src=/vc/katex/katex.min.js></script>
<script defer src=/vc/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>
\[ \mathcal{O}(n\log{}n + n*m) \]
</span>
donde n es el número de polígonos y m es el número de píxeles a rellenar.</p>
<h3 id=complejidad-espacial>
Complejidad espacial
<a class=anchor href=#complejidad-espacial>#</a>
</h3>
<p>El peor caso de complejidad espacial del algoritmo del pintor es <span>
\[ \mathcal{O}(n+m) \]
</span>
donde n es el número de polígonos y m es el número de píxeles a rellenar.</p>
<table>
<thead>
<tr>
<th>Ventajas</th>
<th>Limitaciones</th>
</tr>
</thead>
<tbody>
<tr>
<td><ul><li><strong>Estructura gráfica básica:</strong> El algoritmo no es tan complejo en estructura. Esta simplicidad lo hace útil en escenarios de gráficos de poca dificultad.</li><li><strong>Eficiencia de la memoria:</strong> El algoritmo prioriza el uso eficiente de la memoria, pero a expensas de una mayor procesamiento, ya que se deben renderizar todas las partes de todas las imágenes.</li></ul></td>
<td><ul><li><strong>Superposición cíclica:</strong> En el caso de superposición cíclica, es imposible determinar qué polígono está por encima de los demás. En este caso, los polígonos se deben cortar para permitir la ordenación.</li><li><strong>Polígonos penetrantes:</strong> La perforación de polígonos surge cuando un polígono se cruza con otro. Este problema se puede resolver cortando los polígonos.</li></ul></td>
</tr>
</tbody>
</table>
<h3 id=referencias>
Referencias
<a class=anchor href=#referencias>#</a>
</h3>
<p>Computer Graphics Painter’s Algorithm - javatpoint. (s. f.). Www.Javatpoint.Com. Recuperado 12 de diciembre de 2021, de <a href=https://www.javatpoint.com/computer-graphics-painter-algorithm>https://www.javatpoint.com/computer-graphics-painter-algorithm</a></p>
<p>Wikipedia contributors. (2021, 23 noviembre). Painter’s algorithm. Wikipedia. Recuperado 12 de diciembre de 2021, de <a href=https://en.wikipedia.org/wiki/Painter%27s_algorithm>https://en.wikipedia.org/wiki/Painter%27s_algorithm</a></p>
<p>GeeksforGeeks. (2021, 21 noviembre). Painter’s Algorithm in Computer Graphics. Recuperado 12 de diciembre de 2021, de <a href=https://www.geeksforgeeks.org/painters-algorithm-in-computer-graphics/>https://www.geeksforgeeks.org/painters-algorithm-in-computer-graphics/</a></p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/VisualComputing-vc20212/vc/commit/c2cb8816524a2b318586fb519a5a963a72be24d7 title="Last modified by Andres Ardila | December 13, 2021" target=_blank rel=noopener>
<img src=/vc/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 13, 2021</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#painters-algorithm>Painters' Algorithm</a>
<ul>
<li>
<ul>
<li><a href=#pseudocódigo>Pseudocódigo</a></li>
<li><a href=#complejidad-temporal>Complejidad temporal</a></li>
<li><a href=#complejidad-espacial>Complejidad espacial</a></li>
<li><a href=#referencias>Referencias</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>