[{"id":0,"href":"/vc/docs/shortcodes/Integrantes/","title":"Integrantes","section":"Shortcodes","content":"Integrantes #    Alejandra Zambrano  Alejandra Zambrano # Quien soy # Tengo 21 años y voy en noveno semestre. Llevo trabajando en desarrollo front-end con asp.net y C# desde hace maso menos un año. Adicional recientemente estoy trabajando como monitora en un diplomado de Python de la universidad. En que me gustaría enfocarme # Me apasiona el aprendizaje de maquina, ya he hecho diferentes cursos de coursera relacionados con el tema y me enamore.   Andres Ardila  Andres Ardila # Quien soy # Soy estudiante de 9no semestre de Ingeniería de Sistemas de la Universidad Nacional de Colombia. Tengo 23 años y soy de Bogotá, Colombia En que me gustaría enfocarme # No lo sé aún, quizas en la rama administrativa de la carrera. Hobbies # Me gusta el fútbol y los videojuegos. Experiencia con graficos # En asignaturas pasadas hemos intentado jugar con estilos css y en un pasado con interfaces gráficas de Java.   Catalina Aldana  Catalina Aldana # Quien soy # Soy estudiante de noveno semestre de Ingenieria de Sistemas de la Universidad Nacional de Colombia. Tengo 22 años y naci en Bogota, Colombia. En que me gustaria enfocarme # Aun no tengo muy claro en que area de la carrera me gustaria enfocarme, creo que comenzare con desarrollo de software y a medida que vaya ampliando mi conocimiento y experiencia decidire en que area trabajar.   Diego Bayona  Diego Bayona # Quien soy # Soy estudiante de noveno semestre de Ingenieria de Sistemas y Computacion de la Universidad Naciolnal de Colombia, tengo 21 años, he trabajado como ayudante de desarrollo para proyectos en la universidad y como tutor de programacion, mis lenguajes preferidos son python, javascript, C++ y en cuanto a desarrollo me gusta mas la parte enfocada al frontend en frameworks como React.js y Vue.js   Lucas Peña  Lucas Peña # Quienes somos # Soy Lucas Peña tengo 22 años y soy estudiante de noveno semestre de Ingenieria de Sistemas en la Universida Nacional de Colombia. Actualmente trabajo como desarrollador de software en una empresa enfocada a las telecomunicaciones, desarrollo principalmente en C#. En que me gustaría enfocarme # Aunque actualmente soy desarrollador de software, no creo que sea el área donde quiera enfocarme. Siempre he tenido un fuerte interes por los videojuegos, así que esa podría ser el área en la que me gustaría enfocarme.   Test  ##TEST let img; function preload(){ img = loadImage(\u0026#39;https://pbs.twimg.com/profile_images/1317243402396831744/vOz-5Cju_400x400.jpg\u0026#39;); } function setup() { BG = color(\u0026#34;#f1f1f1\u0026#34;); FG = color(\u0026#34;#111111\u0026#34;); createCanvas(700, 700); img.resize(700, 700); } function draw() { background(BG); fill(FG); noStroke(); let ratio = float(height)/float(width); let tilesX = map(mouseX, 0, width, 10, 100); let tilesY = ratio * tilesX; let tileSize = width / tilesX; for (let y = 0; y \u0026lt; img.height; y \u0026#43;= tileSize) { for (let x = 0; x \u0026lt; img.   "},{"id":1,"href":"/vc/docs/shortcodes/Integrantes/Alejandra-Zambrano/","title":"Alejandra Zambrano","section":"Integrantes","content":"Alejandra Zambrano #  Quien soy #  Tengo 21 años y voy en noveno semestre. Llevo trabajando en desarrollo front-end con asp.net y C# desde hace maso menos un año. Adicional recientemente estoy trabajando como monitora en un diplomado de Python de la universidad.\nEn que me gustaría enfocarme #  Me apasiona el aprendizaje de maquina, ya he hecho diferentes cursos de coursera relacionados con el tema y me enamore. El siguiente año tendre la oportunidad de hacer una pasantía en USA en una investigación relacionada con procesamiento de imagenes con redes neuronales.\nHobby #  Me encanta el deporte, solía entrenar baloncesto pero me toco dejarlo. Actualmente me gusta mucho ejercitarme sola y disfruto de cantar y bailar.\nExperiencia con graficos #  La unica experiencia con gráficos es que en primer semestre hice un juego parecido a Rapid Ball con Processing, pero la verdad ya no me acuerdo mucho del tema. Estoy emocionada de aprender mas del tema.\nDynamic Kanizsa Illusion #       let angle = 0 function setup() { createCanvas(400, 400); } function draw() { background(220); //First fill(255, 0, 0) stroke(255,255,0) strokeWeight(2) push() translate(50, 150) rotate(HALF_PI \u0026#43; angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(150, 150) rotate(HALF_PI * 2 - angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(150, 250) rotate(HALF_PI * 3 \u0026#43; angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(50, 250) rotate(HALF_PI * 4 - angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() //Second fill(0,163,0) stroke(255,255,0) strokeWeight(2) push() strokeWeight(2) translate(250, 150) rotate(HALF_PI * 3 - angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(350, 150) rotate(HALF_PI * 4 \u0026#43; angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(250, 250) rotate(HALF_PI * 2 \u0026#43; angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() push() strokeWeight(2) translate(350, 250) rotate(HALF_PI - angle) arc(0, 0, 80, 80, PI, HALF_PI) pop() angle \u0026#43;= 0.003 }      \"  creds: (https://naziafakhruddin.medium.com/creating-illusions-in-p5-js-dynamic-kanizsa-illusion-part-4-af9fe72c5ec7)\nExplicacion #  Con esta ilusion el psicologo italiano Kanizsa nos muestra un ejemplo de terminacion modal de contornos. La terminacion modal se da cuando se perciben ciertos bordes creados por un limite de luminancia, color o textura cuando no existe tal limite. A esto tambien se le ha llamado \u0026ldquo;Law of clousure\u0026rdquo; según este principio los objetos que se agrupan tienden a verse como parte de un todo. Tendemos a ignorar los espacios y percibir las líneas de contorno para formar figuras y formas familiares para nosotros.\nVisto de una manera mas neurocientifica \u0026ldquo;los grupos de células neuronales ven roturas en las líneas o formas, y si no se les da más información, asumirán que hay una figura delante de las líneas. Los científicos creen que esto sucede porque el cerebro ha sido entrenado para ver la ruptura de las líneas como un objeto que podría representar una amenaza potencial. Con la falta de información adicional, el cerebro yerra por el lado de la seguridad y percibe el espacio como un objeto. El círculo es el objeto más simple y simétrico, por lo que la mente generalmente ve un círculo a menos que se haga un esfuerzo activo para ver una forma alternativa. [1]\u0026rdquo;\n[1]\u0026ldquo;The Grid illusion of Spot 06\u0026rdquo; The Visual Perception Lab. Retrieved December 4, 2007.\ncreds: (https://www.illusionsindex.org/i/kanizsa-triangle)\n"},{"id":2,"href":"/vc/docs/shortcodes/Integrantes/Andres-Ardila/","title":"Andres Ardila","section":"Integrantes","content":"Andres Ardila #  Quien soy #  Soy estudiante de 9no semestre de Ingeniería de Sistemas de la Universidad Nacional de Colombia. Tengo 23 años y soy de Bogotá, Colombia\nEn que me gustaría enfocarme #  No lo sé aún, quizas en la rama administrativa de la carrera.\nHobbies #  Me gusta el fútbol y los videojuegos.\nExperiencia con graficos #  En asignaturas pasadas hemos intentado jugar con estilos css y en un pasado con interfaces gráficas de Java.\n     function setup() { createCanvas(1300,700); noStroke(); cred=color(255,0,0); cblack=color(0,0,0); init=7; } function draw() { if(init==7) { push(); let offset=[0,40,80,40,0,40,80,40,0,40]; xc=100; yc=150; let dx=20; background(255); stroke(cblack); fill(cblack); strokeWeight(10); for(let nl=0;nl\u0026lt;8;nl\u0026#43;\u0026#43;) { stroke(cred); line(xc,yc\u0026#43;nl*85,xc\u0026#43;1070,yc\u0026#43;nl*85); for(let i=0;i\u0026lt;6;i\u0026#43;\u0026#43;) { noStroke(); rect(xc\u0026#43;i*180\u0026#43; offset[nl],yc\u0026#43;nl*85-80,85,78); } } pop(); } }      \"  Fuente: https://openprocessing.org/sketch/1238842\nIlusión de la pared de la cafetería #  La ilusión de la pared de la cafetería es un tipo de ilusión óptico-geométrica, en la que líneas rectas paralelas que dividien líneas entre filas formadas por baldosas blancas y negras alternas y escalonadas, aparentan estar inclinadas.\nEn la construcción de la ilusión óptica, a menudo cada \u0026ldquo;baldosa\u0026rdquo; está rodeado por una capa de \u0026ldquo;mortero\u0026rdquo; de un tono intermedio entre los colores oscuros y claros.\nEn el primer intento de su deconstrucción, la ilusión fue atribuida en gran parte al fenómeno de la irradiación, y a la dispersión de la luz entre zonas oscuras y zonas brillantes en la imagen retinal. El efecto desaparece cuando el blanco y el negro son reemplazados por colores diferentes, pero del mismo brillo.​ Pero un componente residual de la ilusión permanece incluso cuando se eliminan los factores óptico y retinal. Las polaridades de contraste parecen ser el factor que determina el aspecto inclinado de las líneas horizontales.\nTomado de: https://es.wikipedia.org/wiki/Ilusi%C3%B3n_de_la_pared_de_la_cafeter%C3%ADa\n"},{"id":3,"href":"/vc/docs/shortcodes/Integrantes/Catalina-Aldana/","title":"Catalina Aldana","section":"Integrantes","content":"Catalina Aldana #  Quien soy #  Soy estudiante de noveno semestre de Ingenieria de Sistemas de la Universidad Nacional de Colombia. Tengo 22 años y naci en Bogota, Colombia.\nEn que me gustaria enfocarme #  Aun no tengo muy claro en que area de la carrera me gustaria enfocarme, creo que comenzare con desarrollo de software y a medida que vaya ampliando mi conocimiento y experiencia decidire en que area trabajar.\nHobby #  Me gusta ver series, pasar tiempo con mi perro, salir a caminar y escuchar musica.\nExperiencia con graficos #  Tengo una experiencia en graficos muy basica. En primeros semestres hice algunos proyectos pequeños en Processing y juegos sencillos en Java.\nHermann Grid Ilussion #       function setup() { createCanvas(625, 625); } function draw() { background(0); if (mouseX \u0026lt; 313) { HermmanGrid() // Left } else { SGridIlussion() // Right } } function HermmanGrid(){ for(let i=50; i \u0026lt; height; i \u0026#43;= 50){ for(let j=50; j \u0026lt; width; j \u0026#43;= 50){ stroke(255); strokeWeight(10); line(0,i,width,i); line(j,0,j,height); } } } function SGridIlussion(){ for(let i=50; i \u0026lt; height; i \u0026#43;= 50){ for(let j=50; j \u0026lt; width; j \u0026#43;= 50){ stroke(150); strokeWeight(10); line(0,i,width,i); line(j,0,j,height); } } for(let i=50; i \u0026lt; height; i \u0026#43;= 50){ for(let j=50; j \u0026lt; width; j \u0026#43;= 50){ noStroke(); fill(255); ellipse(i,j,15,15); } } }      \"  Explicacion #  Cuando el espectador mira la cuadrícula, los puntos blancos y el centro de cada “corredor” parecen cambiar entre el blanco y el gris. Los investigadores como Baumgartner han utilizado tradicionalmente lo que se conoce como inhibición lateral para explicar por qué las personas ven estas áreas grises. Las neuronas que transmiten señales desde el ojo al cerebro, conocidas como “células ganglionares de la retina” le corresponde una pequeña región de la retina llamada campo receptivo, donde los conos y bastones fotorreceptores pueden desencadenar una respuesta eléctrica en esa célula. Los campos receptivos de las células ganglionares adyacentes pueden superponerse.\nSin embargo, existe evidencia que sugiere que esta explicación probablemente sea inexacta. El hecho de que la ilusión no depende del tamaño, se puede ver con la inversión del contraste y se puede negar distorsionando ligeramente las líneas, se han citado como razones por las que la teoría clásica está equivocada. Una posible explicación que se ha propuesto se conoce como la teoría de la celda simple.\n"},{"id":4,"href":"/vc/docs/shortcodes/Integrantes/Diego-Bayona/","title":"Diego Bayona","section":"Integrantes","content":"Diego Bayona #  Quien soy #  Soy estudiante de noveno semestre de Ingenieria de Sistemas y Computacion de la Universidad Naciolnal de Colombia, tengo 21 años, he trabajado como ayudante de desarrollo para proyectos en la universidad y como tutor de programacion, mis lenguajes preferidos son python, javascript, C++ y en cuanto a desarrollo me gusta mas la parte enfocada al frontend en frameworks como React.js y Vue.js\nQue me gusta de la carrera #  De la carrera me gusta el enfoque en proyectos practicos que nos fuerce a demostrar nuestras capacidades y nuestro trabajo en equipo, me gusta la linea de desarrollo y arquitectura de software, cibreseguridad entre otras\u0026hellip;\nHobbys #  Jugar videojuegos (principalmente competitivos), ver series, aprender idiomas, aprender cosas nuevas\nExperiencia con graficos #  No poseo experiencia mas alla de el desarrollo de interfaces graficas para aplicaciones web\nEbbinghaus illusion #       function setup() { createCanvas(600, 400); } function draw() { background(220); //mapping of mouseX variable and putting in the local variable\u0026#39;k\u0026#39;. let k = map(mouseX, 0, width, 200, 0) //Circle 1 noStroke() fill(\u0026#39;yellow\u0026#39;) ellipse(160, 200, 50, 50) //Circle 1 petals colour fill(155, 0, 215, k) //upper petals ellipse(110, 120, 90, 90) ellipse(210, 120, 90, 90) //lower petals ellipse(110, 280, 90, 90) ellipse(210, 280, 90, 90) //sides petals ellipse(60, 200, 90, 90) ellipse(260, 200, 90, 90) //Circle 2 fill(\u0026#39;yellow\u0026#39;) ellipse(450, 200, 50, 50) //Circle 2 petals color fill(155, 0, 215, k) //up and down petals ellipse(450, 154, 25, 25) ellipse(450, 246, 25, 25) // side petals ellipse(400, 200, 25, 25) ellipse(500, 200, 25, 25) //lower middle ellipse(415, 235, 25, 25) ellipse(485, 235, 25, 25) //upper middle ellipse(415, 164, 25, 25) ellipse(485, 164, 25, 25) }      \"  Explicacion #  Nombrada por su descubridor, el psicologo aleman Hermann Ebbinghaus, esta ilusion juega un papel fundamental en el debate sobre la existencia de caminos separados en el cerebro para la percepción y la acción. La razon es porque la ilusión distorsiona la percepcion del tamaño pero no la acción, pero multiples estudios se han hecho debatiendo como esta ilusion afecta el cerebro. La clave es el contraste de tamaños y como el cerebro relaciona estos con como percibe la ilusión, y atraves de los años se han hecho multiples versiones de esta ilusion con tal de probar sus efectos, lo mas reciente fue hecho por el italiano Gianni A. Sarcone que contradijo la ilusion haciendo la suya propia, demostrando que no siempre la percepcion se ve alterada por el contraste de tamaños.\n"},{"id":5,"href":"/vc/docs/shortcodes/Integrantes/Lucas-Pe%C3%B1a/","title":"Lucas Peña","section":"Integrantes","content":"Lucas Peña #  Quienes somos #  Soy Lucas Peña tengo 22 años y soy estudiante de noveno semestre de Ingenieria de Sistemas en la Universida Nacional de Colombia. Actualmente trabajo como desarrollador de software en una empresa enfocada a las telecomunicaciones, desarrollo principalmente en C#.\nEn que me gustaría enfocarme #  Aunque actualmente soy desarrollador de software, no creo que sea el área donde quiera enfocarme. Siempre he tenido un fuerte interes por los videojuegos, así que esa podría ser el área en la que me gustaría enfocarme.\nHobby #  Mis hobbies son jugar videojuegos, hacer caminatas, escuchar música y jugar volleyball.\nExperiencia con graficos #  No cuento con mucha experiencia en gráficos. En primer semestre programé un juego sencillo en Processing y en segundo semestre un juego más complejo en Java.\n     // PBa // 2021-06-17 // Optical Illusio // Ideas from https://mathworld.wolfram.com/Illusion.html // Ideas from https:/michaelbach.de/ot/ function setup() { createCanvas(640,640); noStroke(); cred=color(255,0,0); cgreen=color(0,255,0); cblue=color(0,0,255); clblue=color(200,200,240); cbackg=color(200,200,255); cyellow=color(254,255,23); corange=color(234,214,28); cwhite=color(255,255,255); cgrey=color(74,74,74); cblack=color(0,0,0); init=0; hide=false; } function draw() { push(); xc = 0; yc = 0; let dx = 68; background(255); fill(cyellow); stroke(cblack); rect(1000, 100, 150, 40, 4, 4); fill(cblack); stroke(cblack); strokeWeight(1); if (hide == false) { for (let nl = 0; nl \u0026lt; 9; nl\u0026#43;\u0026#43;) { for (let nc = 0; nc \u0026lt; 9; nc\u0026#43;\u0026#43;) { if (nc % 2 \u0026#43; nl % 2 == 1) { fill(cwhite); } else { fill(cblack); } rect(xc \u0026#43; nc * dx, yc \u0026#43; nl * dx, 70, 70); if (nc % 2 \u0026#43; nl % 2 == 1) { fill(cblack); } else { fill(cwhite); } //Esquina superior izq. if (nc \u0026lt; 4 \u0026amp; nl \u0026lt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Esquina superior der. if (nc \u0026gt; 4 \u0026amp; nl \u0026lt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Centro izquierda if (nl == 4 \u0026amp; nc \u0026lt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Centro derecha if (nl == 4 \u0026amp; nc \u0026gt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Esquina inferior izq. if (nc \u0026lt; 4 \u0026amp; nl \u0026gt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Esquina inferior der. if (nc \u0026gt; 4 \u0026amp; nl \u0026gt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Centro superior. if (nc == 4 \u0026amp; nl \u0026lt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 57, 19); circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 57, 19); } //Centro inferior if (nc == 4 \u0026amp; nl \u0026gt; 4) { circle(xc \u0026#43; nc * dx \u0026#43; 13, yc \u0026#43; nl * dx \u0026#43; 13, 19); circle(xc \u0026#43; nc * dx \u0026#43; 57, yc \u0026#43; nl * dx \u0026#43; 13, 19); } } //end nc } } if (hide == true) { for (let nl = 0; nl \u0026lt; 9; nl\u0026#43;\u0026#43;) { for (let nc = 0; nc \u0026lt; 9; nc\u0026#43;\u0026#43;) { if (nc % 2 \u0026#43; nl % 2 == 1) { fill(cwhite); } else { fill(cblack); } rect(xc \u0026#43; nc * dx, yc \u0026#43; nl * dx, 70, 70); } } } pop(); } function mousePressed() { console.log(\u0026#34;CLICK\u0026#34;); hide = !hide; console.log(hide); }      \"  Explicación #  La ilusión del tablero protuberante se le atribuye a Akiyoshi Kitaoka. Pareciera que el tablero tiene un tipo de relieve curvo.\nSe piensa que esto sucede ya que los puntos no se tocan los bordes de los cuadrados, se especula que el cerebro interpreta el espacio entre los puntos y los bordes como líneas, esto hace que ya no percibamos los ángulos como rectos, sino como agudos u obtusos.\nEl efecto se hace más fuerte entre más pequeño sea el tablero, entonces si se alejan de la pantalla parecera que el tablero se empieza a curvar.\nAplicación #  Este efecto visual puede ser utilizado en publicidad para llamar la atención de las personas y también puede tener una aplicación en videojuegos.\n"},{"id":6,"href":"/vc/docs/shortcodes/Integrantes/Test/","title":"Test","section":"Integrantes","content":"##TEST\n     let img; function preload(){ img = loadImage(\u0026#39;https://pbs.twimg.com/profile_images/1317243402396831744/vOz-5Cju_400x400.jpg\u0026#39;); } function setup() { BG = color(\u0026#34;#f1f1f1\u0026#34;); FG = color(\u0026#34;#111111\u0026#34;); createCanvas(700, 700); img.resize(700, 700); } function draw() { background(BG); fill(FG); noStroke(); let ratio = float(height)/float(width); let tilesX = map(mouseX, 0, width, 10, 100); let tilesY = ratio * tilesX; let tileSize = width / tilesX; for (let y = 0; y \u0026lt; img.height; y \u0026#43;= tileSize) { for (let x = 0; x \u0026lt; img.width; x \u0026#43;= tileSize) { let c = img.get(x, y); let b = map(brightness(c), 0, 255, 1, 0); push(); translate(x, y); rect(0, 0, b * tileSize, b * tileSize); pop(); } } }      \"  "},{"id":7,"href":"/vc/docs/shortcodes/Rendering/","title":"Rendering","section":"Shortcodes","content":"Rendering #    Painters Algorithm  Painters' Algorithm # El algoritmo del pintor, también algoritmo de ordenación de la profundidad o relleno prioritario, es un algoritmo para la determinación de la superficie visible en gráficos 3D,que funciona polígono a polígono para la eliminación de superficies ocultas al punto de vista del observador. Este algoritmo crea imágenes clasificando los polígonos dentro de la imagen por su profundidad y colocando cada polígono en orden desde el objeto más lejano al más cercano.   Rasterización  Rasterización # Explicación # Este algoritmo de rasterización utiliza el brillo de cada pixel para asignar el tamaño de cada celda. Esto se asocia mucho a las técnicas de antialiasing, esta técnica se trata en que si un pixel se encuentra dentro de cierta area, basado en el brillo de este, se pinta o no el pixel, la técnica consta en que cada vez se van haciendo más y más subparticiones dentro de los pixeles para así dejar una imagen clara y lisa.   "},{"id":8,"href":"/vc/docs/shortcodes/Rendering/Painters-Algorithm/","title":"Painters Algorithm","section":"Rendering","content":"Painters' Algorithm #  El algoritmo del pintor, también algoritmo de ordenación de la profundidad o relleno prioritario, es un algoritmo para la determinación de la superficie visible en gráficos 3D,que funciona polígono a polígono para la eliminación de superficies ocultas al punto de vista del observador. Este algoritmo crea imágenes clasificando los polígonos dentro de la imagen por su profundidad y colocando cada polígono en orden desde el objeto más lejano al más cercano.\nFue propuesto inicialmente como un método básico para abordar el problema de la determinación de la superficie oculta por Martin Newell, Richard Newell y Tom Sancha en 1972. Se llama así porque el pintado del cuadro se hace en orden decreciente de la distancia. La distancia es desde el plano de la vista. Los polígonos a más distancia se pintan primero.\nCuando el pintor hace un cuadro, primero pinta todo el lienzo con el color de fondo. Luego, se añaden los objetos más lejanos, como las montañas o los árboles. A continuación, se añaden al cuadro los objetos posteriores o de primer plano.\n Los objetos están dispuestos en orden creciente a la coordenada z. El renderizado se realiza en orden de la coordenada z. Los objetos más lejanos oscurecerán a los cercanos. Los píxeles de la parte trasera sobrescribirán los píxeles de los objetos más lejanos.\nSi los valores z de dos se superponen, podemos determinar el orden correcto a partir del valor Z como se muestra en la figura (a).\nSi los objetos z se superponen entre sí, como en la figura (b), este correcto orden se puede mantener cortando los objetos superpuestos.\n Pseudocódigo #  Pasos realizados en la clasificación en profundidad\n Ordenar todos los polígonos según la coordenada z. Encontrar ambigüedades: encontrar si la coordenada z se superpone, dividir el polígono si es necesario. Convertir cada polígono en orden creciente de la coordenada z.  sort polygons by depth for each polygon p: for each pixel that p covers: paint p.color on pixel Se aplica la prueba:\n ¿A está detrás de B y no se solapa con él en la dimensión de Z como se muestra en la figura (a)? Si A está detrás de B en z y no se solapa en x o y como se muestra en la fig (b) Si A está detrás de B en Z y totalmente fuera de B con respecto al plano de la vista como se muestra en la fig (c) Si A está detrás de B en Z y B está totalmente dentro de A con respecto al plano de visión, como se muestra en la figura (d)   Complejidad temporal #  La complejidad temporal depende en gran medida del algoritmo de ordenamiento utilizado para ordenar los polígonos. Suponiendo el uso del algoritmo de ordenamiento más óptimo, el algoritmo de pintor tiene una complejidad en el peor de los casos:   \\[ \\mathcal{O}(n\\log{}n \u0026#43; n*m) \\]  donde n es el número de polígonos y m es el número de píxeles a rellenar.\nComplejidad espacial #  El peor caso de complejidad espacial del algoritmo del pintor es  \\[ \\mathcal{O}(n\u0026#43;m) \\]  donde n es el número de polígonos y m es el número de píxeles a rellenar.\n   Ventajas Limitaciones     Estructura gráfica básica: El algoritmo no es tan complejo en estructura. Esta simplicidad lo hace útil en escenarios de gráficos de poca dificultad.Eficiencia de la memoria: El algoritmo prioriza el uso eficiente de la memoria, pero a expensas de una mayor procesamiento, ya que se deben renderizar todas las partes de todas las imágenes. Superposición cíclica: En el caso de superposición cíclica, es imposible determinar qué polígono está por encima de los demás. En este caso, los polígonos se deben cortar para permitir la ordenación.Polígonos penetrantes: La perforación de polígonos surge cuando un polígono se cruza con otro. Este problema se puede resolver cortando los polígonos.    Referencias #  Computer Graphics Painter’s Algorithm - javatpoint. (s. f.). Www.Javatpoint.Com. Recuperado 12 de diciembre de 2021, de https://www.javatpoint.com/computer-graphics-painter-algorithm\nWikipedia contributors. (2021, 23 noviembre). Painter’s algorithm. Wikipedia. Recuperado 12 de diciembre de 2021, de https://en.wikipedia.org/wiki/Painter%27s_algorithm\nGeeksforGeeks. (2021, 21 noviembre). Painter’s Algorithm in Computer Graphics. Recuperado 12 de diciembre de 2021, de https://www.geeksforgeeks.org/painters-algorithm-in-computer-graphics/\n"},{"id":9,"href":"/vc/docs/shortcodes/Rendering/Rasterizaci%C3%B3n/","title":"Rasterización","section":"Rendering","content":"Rasterización #  Explicación #  Este algoritmo de rasterización utiliza el brillo de cada pixel para asignar el tamaño de cada celda. Esto se asocia mucho a las técnicas de antialiasing, esta técnica se trata en que si un pixel se encuentra dentro de cierta area, basado en el brillo de este, se pinta o no el pixel, la técnica consta en que cada vez se van haciendo más y más subparticiones dentro de los pixeles para así dejar una imagen clara y lisa.\nLa definición de las celdas de la rasterización se puede cambiar moviendo el mouse de horizontalmente. Veamos si sirve\u0026hellip;\n     let img; function preload(){ img = loadImage(\u0026#39;https://pbs.twimg.com/profile_images/1317243402396831744/vOz-5Cju_400x400.jpg\u0026#39;); } function setup() { BG = color(\u0026#34;#f1f1f1\u0026#34;); FG = color(\u0026#34;#111111\u0026#34;); createCanvas(700, 700); img.resize(700, 700); } function draw() { background(BG); fill(FG); noStroke(); let ratio = float(height)/float(width); let tilesX = map(mouseX, 0, width, 10, 100); let tilesY = ratio * tilesX; let tileSize = width / tilesX; for (let y = 0; y \u0026lt; img.height; y \u0026#43;= tileSize) { for (let x = 0; x \u0026lt; img.width; x \u0026#43;= tileSize) { let c = img.get(x, y); let b = map(brightness(c), 0, 255, 1, 0); push(); translate(x, y); rect(0, 0, b * tileSize, b * tileSize); pop(); } } }      \"  "}]